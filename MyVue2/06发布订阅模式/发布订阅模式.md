  # 观察者模式
  观察者模式，我认为是是单向的时间流
  观察者需要提供一些 API 给被观察者使用
  观察者在发生一些变化时，调用该 API 将数据传递给观察者。 
  
  #  发布订阅模式
  发布订阅模式 ，我认为是双向的。
  也就是它有一个发布者，一个订阅者，还有一个中间对象
  而发布者于中间对象就类似于观察者模式 。 发布者调用中间对象 API 将数据传递给中间对象
  而订阅者也需要调用一些 API ，不过它更类似于事件 。将回调传递给中间对象
  中间对象在有新数据时调用回调 ，并把参数传递给订阅者


   - 需要有一个容器，存储可以被除非的东西（函数 ，对象（包含一些方法））
   - 需要一个方法 ，可以将东西传入容器
   - 需要一个方法，从将容器中的东西取出使用 （调用函数 ，执行对象方法）

当然，也不一定需要提供事件传递参数
可以将数据放在一个公共地方 。通知对方去取是一样的

# vue 的使用
vue 使用了发布订阅模式 。
不过如何实现发布订阅模式呢？
就需要借助观察者模式 ，以及事件

Watcher + Event = 发布订阅模式


## 关于全局 watch 和局部 watch
每一个组件都会有一个 watch 
全局也会有一个 watch

全局 watch 处理的就是页面的刷新
为了优化 ，不可能一个变化，就全部更新
也就是需要区分哪些有变化，哪些没有变化。
因此通过在 get 和 set 时 ，就可以收集 ，哪些已经变化
哪些需要改变。

因此 ，对于每个被劫持的数据 ，都会有一个 Dep 。 它收集的是依赖者 。
比如除了页面使用，还可能在 computed 中使用 。也可能不使用 。那么 dep 就是空

Dep 相当于是谁需要我 ，那么我之后就更新谁

那么依赖者是谁呢？
就是 watcher
watch 会有对应的回调或者方法去执行 。时依赖方更新

而 watch 需要有对应的更新方法 。watch 也有一个 deps 属性。
它存储的是 watcher 对应的属性。
因为它们是多对多的关系 。
一个属性 ，可以被多个 watcher 所依赖
而一个 watcher ，也可能在多个属性中的 Dep 中

比如一个组件有多个属性 。那么这个页面有一个 watcher ，是负责该页面的更新的
那么这些属性都有添加这个 watcher 。
而此 watcher 也会有这些属性的 dep 。

之所以区分 watcher 。 是因为需要将组件独立出来。
当组件内的属性变化时 ，并不会影响其他组件 。

在属性进行 get 时 ，搜集 watcher , 即知道谁依赖了这个属性
 在 set 后 ，就会把 收集到 的 watcher 添加到 queueWatcher 中
queueWatcher 的任务就是收集全部需要更新的 watcher ，并依次执行更新

这里的好处就是 ， 只有被 get 的属性，才是被需要的属性 。才会收集 watcher
也就是如果属性 ，就没有被 get 过 ，那么无论怎么刷新 ，都不影响

好处二就是 ，针对化处理组件。
不需要一点改变就全局更新 。
需要更新的 watcher 是被 set 的属性的依赖 watcher 。
针对化更新组件 。优化性能。

在更新完后 。 数据变动的属性 ，需要重新收集依赖 。全局 watcher 需要清空收集的局部 watcher

为什么需要重新收集依赖 watcher . 因为页面的变化，可能使一些依赖已经不用的。
并且在组件刷新时，局部组件的数据会被重新 get 一次或多次 。因此可以正常的完成重新收集


那么到这里就有一个问题 ： 
- 就是属性如何知道，谁依赖了它。也就是它的 Dep 如何添加 watcher
 
在 vue 中，使用了一个栈缓存。因为渲染组件时，是一个一个组件处理的。这意外者，就跟函数调用一样。
可以通过栈，保存之前的还未结束的。栈顶是当前执行着的。
那么每个组件只需要获取当前栈顶的 watcher 即可。
栈也是全局可以访问到的

那么这里的问题就是什么时候压入栈，什么时候出栈



